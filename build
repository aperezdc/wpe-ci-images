#! /bin/zsh
emulate -L zsh
setopt multios err_return

# Make sure no aliases are defined. At all.
unalias -a -s

# Automatically pick helpers from the functions/ subdir.
fpath="${0:A:h}/functions" autoload -RUz "${0:A:h}/functions"/*(.:t)

# Handle all the ': require ...' lines.
declare -a required=()
declare -a line
while read -A line ; do
	[[ ${#line} -gt 2 && ${(f)line[1,2]} = :\ require ]] || continue
	required+=( "${(@)line[3,-1]}" )
done < "${0:A:h}/functions"/*(.)

require "${(u)required[@]}"
require pigz tar pv fakeroot fakechroot

unset line
unset required

zmodload zsh/zutil
zmodload zsh/stat

# Parse command line options.
declare -a PKGLIST_DEFINES
declare -a pkglist_files
declare -a json_configs
declare -A OPTS=()

zparseopts -A OPTS -D -M -E \
	h -help=h \
	o: -output:=o \
	D+:-=PKGLIST_DEFINES -define+:-=D \
	p+:-=pkglist_files -pkglist+:-=p \
	C+:-=json_configs -image-config+:-=C

pkglist_files=( "${pkglist_files[@]#-p}" )
json_configs=( "${json_configs[@]#-C}" )

if [[ ${OPTS[-h]+set} = set ]] ; then
	show-help "${0}" 0
fi

declare -a packages=( "$@" )
if [[ ${#pkglist_files} -gt 0 ]] ; then
	packages=( $(pkglist "${pkglist_files[@]}") "$@" )
fi

[[ -n ${OPTS[-o]} ]] || die 'No image output path specified'
[[ ${#packages} -gt 0 ]] || die 'No packages specified'

declare -r O=${OPTS[-o]}
declare -r rootfs_path="${O}/rootfs"
declare -r blobs_path="${O}/blobs"
declare -r cache_path="${O}/cache"


function fake-init
{
	: > "${O}/faked.state"
}

function fake
{
	echo ":: fake: $*"
	fakechroot -e none -- fakeroot -i "${O}/faked.state" -s "${O}/faked.state" -- "$@"
}


if [[ ! -r ${rootfs_path}.done ]] ; then
	rm -rf "${rootfs_path}"
	mkdir -p \
		"${rootfs_path}"/var/{cache/pacman/pkg,lib/pacman,log} \
		"${rootfs_path}"/{dev,proc,sys} \
		"${cache_path}"
	# TODO: Add package in imagebuild.pkglist
	# bindfs --chown-ignore --chgrp-ignore --chmod-ignore --xattr-none --delete-deny --rename-deny \
	#	/dev "${rootfs_path}/dev"
	: > "${O}/pacman.log"
	fake-init
	reflector --protocol https --score 5 > "${O}/mirrorlist"
	gen-pacman-conf "${O}/mirrorlist" > "${O}/pacman.conf"

	fake pacman -Sy \
		--root "${rootfs_path}" \
		--cachedir "${cache_path}" \
		--logfile "${O}/pacman.log" \
		--config "${O}/pacman.conf" \
		--noconfirm "${packages[@]}"
	# fusermount -u "${rootfs_path}/dev"
	touch "${rootfs_path}.done"
	rm -f "${rootfs_path}.tar.sum" "${rootfs_path}.tar.gz.sum"
fi

if [[ ! -r ${rootfs_path}.tar.sum ]] ; then
	read -r rootfs_size dummy < <(du -s "${rootfs_path}/")
	echo " :: Packaging rootfs..."
	fake tar -C "${rootfs_path}" -cp . | pv -peta -D 3 -s "${rootfs_size}" > "${rootfs_path}.tar"
	sha256 "${rootfs_path}.tar" > "${rootfs_path}.tar.sum"
	rm -f "${rootfs_path}.tar.gz.sum"
fi

if [[ ! -r ${rootfs_path}.tar.gz.sum ]] ; then
	echo " :: Compressing rootfs..."
	pv -peta -D 3 "${rootfs_path}.tar" | pigz -9c > "${rootfs_path}.tar.gz"
	rm "${rootfs_path}.tar"
	sha256 "${rootfs_path}.tar.gz" > "${rootfs_path}.tar.gz.sum"
fi


# FIXME: Un-hardcode os/architecture.
echo "${json_configs[*]}"
json-merge =(gen-image-conf-base linux amd64 "$(< "${rootfs_path}.tar.sum")") \
	"${json_configs[@]}" > "${O}/config.json"
sha256 "${O}/config.json" > "${O}/config.json.sum"

mkdir -p "${blobs_path}"
echo 'Directory Transport Version: 1.1' > "${blobs_path}/version"
ln -f "${rootfs_path}.tar.gz" "${blobs_path}/$(< "${rootfs_path}.tar.gz.sum")"
ln -f "${O}/config.json" "${blobs_path}/$(< "${O}/config.json.sum")"

> "${blobs_path}/manifest.json" <<EOF
{
	"schemaVersion": 2,
	"mediaType": "application/vnd.docker.distribution.manifest.v2+json",
	"config": {
		"mediaType": "application/vnd.docker.container.image.v1+json",
		"digest": "sha256:$(< "${O}/config.json.sum")",
		"size": $(zstat +size "${O}/config.json")
	},
	"layers": [
		{
			"mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
			"digest": "sha256:$(< "${rootfs_path}.tar.gz.sum")",
			"size": $(zstat +size "${rootfs_path}.tar.gz")
		}
	]
}
EOF
